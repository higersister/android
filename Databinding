@BindingAdapter
作用于方法
它定义了xml的属性赋值的java实现
方法必须为公共静（public static）方法，可以有一到多个参数。

问题
在使用databinding的时候，有时候发现：

属性在类中没有对应的setter，如ImageView的android:src，ImageView中没有setSrc()方法，
属性在类中有setter，但是接收的参数不是自己想要的，如android:background属性，对应的setter是setBackgound(drawable)，但是我想传一个int类型的id进去，这时候android:background = “@{imageId}”就不行。
没有对应的属性，但是却要实现相应的功能。

这时候可以使用@BindingAdapter来定义方法，解决上面的问题。

for example
java:
@BindingAdapter("background")
    public static void setBackground(Button btn, int id){
        btn.setBackgroundResource(id);
    }
xml:
 app:background="@{img.id}"
实现双向绑定
public class UserBean extends BaseObservable {

    public ObservableField<String> name = new ObservableField<>();

    public ObservableField<Integer> age = new ObservableField<>();

    public UserBean() {
    }

    public UserBean(String name, int age) {
        this.name.set(name);
        this.age.set(age);
    }

    @Bindable
    public String getName(){
        return name.get();
    }

    public void setName(String name){
        this.name.set(name);
        notifyPropertyChanged(BR.name);
    }

    @Bindable
    public int getAge() {
        return this.age.get();
    }

    public void setAge(int age) {
        this.age.set(age);
        notifyPropertyChanged(BR.age);

    }

}

1、给之前的get方法添加 "@Bindable"注解
2、给之前的set方法的最后边添加"notifyPropertyChanged(BR.字段)"
步骤一的作用就是通过注解的方式，来标记此get属性方法，将来是要自动触发的动作
而步骤二的作用则是，当数据发生变化时，发出此属性已经改变的通知，从而让dataBinding框架去自动调用get方法


用 public ObservableField<String> name = new ObservableField<>()这种方式来创建属性，ObservableField的作用是，当我们实体类中的值发生改变时会自动通知View刷新。用 name.get()获取属性值，用name.set()设置属性值。若想改变一个字段，需要该字段的get方法添加上@Bindable注解，然后给该字段的set方法加上 notifyPropertyChanged(BR.字段名)。

ViewModel仅仅专注于业务的逻辑处理,只做和业务逻辑和业务数据相关的事，UI相关的事情不要写在这里面，ViewModel 层不会持有任何控件的引用，更不会在ViewModel中通过UI控件的引用去做更新UI的事情。但是ViewModel可能会改变数据，由于数据和UI已经绑定到一起了，所以相应的控件上会自动去更新UI。

Model层
Model层就是职责数据获取的，网络请求的逻辑在这里面写，类似于MVP。所以我觉得ViewModel层可以持有一个Model的引用，通知Model获取数据，同时Model在获取到数据之后，回调通知ViewModel进行数据更改，进而使UI得到更新。

总结一下：View层的Activity通过DataBinding生成Binding实例,把这个实例传递给ViewModel，ViewModel层通过把自身与Binding实例绑定，从而实现View中layout与ViewModel的双向绑定。如果不引入ViewModel这一层，还会有一个缺点：一个xml中可能会涉及到多个数据对象，那么我们只有把这个多个数据对象都引入进来，xml布局的清晰程度下降，通过这种方法，我们的layout文件中data标签中只需要引入ViewModel就可以了，其它的数据对象统一在ViewModel中一并处理。


MVVM的问题
第一点：数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。
第二点：对于过大的项目，数据绑定需要花费更多的内存。



